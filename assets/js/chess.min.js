
/* Minimal chess representation with naive move-gen + simple CPU (demo only). */
window.MicroChess=(function(){
  const start=[
   "rnbqkbnr",
   "pppppppp",
   "........",
   "........",
   "........",
   "........",
   "PPPPPPPP",
   "RNBQKBNR"];
  let board=start.map(r=>r.split(""));
  let turn='w';
  function clone(b){ return b.map(r=>r.slice()); }
  function get(){ return board.map(r=>r.join("")); }
  function isWhite(p){ return p>='A'&&p<='Z'; }
  function isBlack(p){ return p>='a'&&p<='z'; }
  function inside(r,c){ return r>=0&&r<8&&c>=0&&c<8; }
  function empty(r,c){ return board[r][c]==='.'; }
  function move(fr,fc,tr,tc){
    const p=board[fr][fc]; if(!p || p==='.'){ return false; }
    const white=isWhite(p); if((white && turn!=='w')||(!white && turn!=='b')) return false;
    // Naive per-piece deltas (very permissive, demo only; no checks)
    let ok=false, dR=tr-fr, dC=tc-fc;
    const tgt=board[tr][tc];
    function pathClear(){ // straight/diag path
      const sr=Math.sign(dR), sc=Math.sign(dC); let r=fr+sr, c=fc+sc;
      while(r!==tr||c!==tc){ if(board[r][c]!=='.') return false; r+=sr; c+=sc; } return true;
    }
    switch(p){
      case 'P': ok=(dC===0 && dR===-1 && tgt==='.') || (dR===-2 && dC===0 && fr===6 && empty(5,fc)&&tgt==='.') || (Math.abs(dC)===1 && dR===-1 && isBlack(tgt)); break;
      case 'p': ok=(dC===0 && dR===1 && tgt==='.') || (dR===2 && dC===0 && fr===1 && empty(2,fc)&&tgt==='.') || (Math.abs(dC)===1 && dR===1 && isWhite(tgt)); break;
      case 'R': ok=(dR===0||dC===0)&&pathClear(); break;
      case 'B': ok=(Math.abs(dR)===Math.abs(dC))&&pathClear(); break;
      case 'Q': ok=((dR===0||dC===0)||Math.abs(dR)===Math.abs(dC))&&pathClear(); break;
      case 'N': ok=(dR*dR+dC*dC===5); break;
      case 'K': ok=(Math.max(Math.abs(dR),Math.abs(dC))===1); break;
      default: ok = tgt==='.' || (white?isBlack(tgt):isWhite(tgt));
    }
    if(!ok || !inside(tr,tc)) return false;
    // Cannot capture same color
    if(tgt!=='.' && ((isWhite(p)&&isWhite(tgt))||(isBlack(p)&&isBlack(tgt)))) return false;
    board[tr][tc]=p; board[fr][fc]='.'; turn=(turn==='w'?'b':'w'); return true;
  }
  function legalMoves(side){
    const moves=[];
    for(let r=0;r<8;r++) for(let c=0;c<8;c++){
      const p=board[r][c]; if(p==='.') continue;
      if(side==='w' && !isWhite(p)) continue; if(side==='b' && !isBlack(p)) continue;
      for(let rr=0;rr<8;rr++) for(let cc=0;cc<8;cc++){
        // try move on a copy
        const b2=clone(board); const t2=turn; // store
        if(move(r,c,rr,cc)){ // executed on real board; undo after checking
          // score: prefer captures
          const score = (b2[rr][cc]!=='.') ? 1 : 0;
          moves.push({fr:r,fc:c,tr:rr,tc:cc,score});
          // undo by restoring board/turn
          board=b2; turn=t2;
        }
      }
    }
    return moves;
  }
  function cpuMove(){
    const side=turn; const mvs=legalMoves(side);
    if(mvs.length===0) return false;
    mvs.sort((a,b)=>b.score-a.score || Math.random()-0.5);
    const m=mvs[0];
    return move(m.fr,m.fc,m.tr,m.tc);
  }
  function reset(){ board=start.map(r=>r.split("")); turn='w'; }
  return {get,move,reset,cpuMove};
})();
